name: Artifact attestations Sign and verify container images with keys

on:
  workflow_call:
    inputs:
      git_tag:
        required: false
        type: string
      sigstore_public_key:
        required: true
        type: string
    secrets:
      gh_token:
        description: 'GitHub Token for authentication'
        required: true
      cosign_password:
        description: 'A password to unlock sigstore private key'
        required: true
      sigstore_private_key:
        description: 'A private sigstore key'
        required: true

env:
  IMAGE_TAG: zig-key-aa
  SIGSTORE_PUBLIC_KEY: ${{ inputs.sigstore_public_key }}

jobs:
  build:
    name: Build a container image
    permissions:
      id-token: write # Use GitHub OIDC provider for Artifact attestations.
      packages: write # Push container images to ghcr.io.
      attestations: write # Generate Artifact attestations.
      contents: write # Create a release.
    runs-on: ubuntu-24.04
    steps:
      - name: Check buildah version
        id: buildah_version
        run: |
          installed_version=$(buildah version --json | jq -r '.version')
          minimum_required_version='1.35.0'
          if dpkg --compare-versions "$installed_version" lt "$minimum_required_version"; then
              printf '%s=%s\n' 'is_old' 'true' >> "$GITHUB_OUTPUT"
          fi

      # Workaround: Ubuntu 24.04 does not have 1.35.0 version of buildah yet. Which introduces annotation support for image manifests.
      - name: Build buildah from sources
        if: ${{ steps.buildah_version.outputs.is_old }}
        env:
          BUILDAH_BRANCH: release-1.41
        run: |
          sudo apt-get -y remove buildah
          sudo apt-get update -y
          sudo apt-get install -y \
              bats \
              btrfs-progs \
              git \
              go-md2man \
              golang \
              libapparmor-dev \
              libglib2.0-dev \
              libgpgme11-dev \
              libseccomp-dev \
              libselinux1-dev \
              make \
              runc \
              skopeo \
              libbtrfs-dev
          git clone --branch "$BUILDAH_BRANCH" --depth 1 --single-branch https://github.com/containers/buildah
          cd buildah
          make
          sudo make install

      - name: Output version of installed buildah
        run: buildah version

      # Workaround for buildah: https://github.com/actions/runner-images/issues/10443
      - name: Workaround for Ubuntu 24.04 LTS
        run: sudo sysctl -w kernel.apparmor_restrict_unprivileged_userns=0

      - name: Checkout
        uses: actions/checkout@v5

      - name: Install Cosign
        uses: sigstore/cosign-installer@v4.0.0
        with:
          cosign-release: 'v3.0.2'

      - name: Create a blob
        id: blob
        run: |
          zig_mirror=$(curl -fsSL https://ziglang.org/download/community-mirrors.txt | shuf -n 1)
          zig_version=$(curl -fsSL https://ziglang.org/download/index.json | jq -r '.master.version')
          zig_tarball_x86_64_linux_master="zig-x86_64-linux-${zig_version}.tar.xz"
          curl -fsSL "${zig_mirror}/${zig_tarball_x86_64_linux_master}" -o "$zig_tarball_x86_64_linux_master"
          printf '%s=%s\n' 'zig_tarball_x86_64_linux_master' "$zig_tarball_x86_64_linux_master" >> "$GITHUB_OUTPUT"

      - name: Build a container image
        id: image
        run: |
          buildah unshare ./zig_container.sh ${{ steps.blob.outputs.zig_tarball_x86_64_linux_master }}
          image_id=$(cat ./image_id.txt)
          printf '%s=%s\n' 'id' "$image_id" >> "$GITHUB_OUTPUT"

      - name: Create a image manifest
        id: image_manifest_local
        env:
          MANIFEST_NAME: zig
        run: |
          image_manifest_local_imageid=$(buildah manifest create \
              --annotation \
              "org.opencontainers.image.source=${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}" \
              ${GITHUB_REPOSITORY##*/}:${MANIFEST_NAME})
          printf '%s=%s\n' 'id' "$image_manifest_local_imageid" >> "$GITHUB_OUTPUT"

      - name: Add image into image manifest
        run: |
          buildah manifest add ${{ steps.image_manifest_local.outputs.id }} ${{ steps.image.outputs.id }}
          buildah images # DEBUG: List images and image manifests
          buildah manifest inspect ${{ steps.image_manifest_local.outputs.id }} # DEBUG: Inspect image manifest

      - name: Login to GHCR.io
        run: |
          # GitHub-hosted runners already have a ${HOME}/.docker/config.json with a credential which has unlimited pull rate and limit on Docker Hub.
          # Append the new credential to the same file and tell buildah and its friends (podman, skopeo etc.) to use it.
          printf '%s' "${{ secrets.gh_token }}" | docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin
          printf '%s=%s\n' 'REGISTRY_AUTH_FILE' "${HOME}/.docker/config.json" >> "$GITHUB_ENV"

      - name: Push image manifest into versioned tag on ghcr.io
        id: image_manifest_ghcr
        run: |
          buildah manifest push \
              --digestfile image_manifest_ghcr_digest.txt \
              ${{ steps.image_manifest_local.outputs.id }} \
              docker://ghcr.io/${GITHUB_REPOSITORY,,}/${IMAGE_TAG}:${{ inputs.git_tag }}
          image_manifest_ghcr_digest=$(cat ./image_manifest_ghcr_digest.txt)
          printf '%s=%s\n' 'digest' "$image_manifest_ghcr_digest" >> "$GITHUB_OUTPUT"

      - name: Sign image manifest on ghcr.io
        env:
          COSIGN_PASSWORD: ${{ secrets.cosign_password }}
          SIGSTORE_PRIVATE_KEY: ${{ secrets.sigstore_private_key }}
        run: |
          cosign sign \
              --key env://SIGSTORE_PRIVATE_KEY \
              --recursive \
              --yes \
              ghcr.io/${GITHUB_REPOSITORY,,}/${IMAGE_TAG}@${{ steps.image_manifest_ghcr.outputs.digest }}

      - name: Create lowercase version of GITHUB_REPOSITORY as a step output
        id: github_repository
        run: printf '%s=%s\n' 'lc' "${GITHUB_REPOSITORY,,}" >> "$GITHUB_OUTPUT"

      - name: Create image tag as a step output
        id: image_ghcr
        run: printf '%s=%s\n' 'tag' "$IMAGE_TAG" >> "$GITHUB_OUTPUT"

      - name: Generate SBOM for container image
        uses: anchore/sbom-action@v0
        with:
          image: ghcr.io/${{ steps.github_repository.outputs.lc }}/${{ steps.image_ghcr.outputs.tag }}@${{ steps.image_manifest_ghcr.outputs.digest }}
          output-file: ./zig-key.spdx.json

      - name: Attest SBOM
        uses: actions/attest-sbom@v3
        id: attest_sbom
        with:
          subject-name: ghcr.io/${{ steps.github_repository.outputs.lc }}/${{ steps.image_ghcr.outputs.tag }}
          subject-digest: ${{ steps.image_manifest_ghcr.outputs.digest }}
          sbom-path: ./zig-key.spdx.json
          push-to-registry: true

      - name: Push image manifest into latest tag too
        run: |
          buildah manifest push \
              ${{ steps.image_manifest_local.outputs.id }} \
              docker://ghcr.io/${GITHUB_REPOSITORY,,}/${IMAGE_TAG}:latest

      - name: Generate artifact attestation
        id: attest_provenance
        uses: actions/attest-build-provenance@v3
        with:
          subject-name: ghcr.io/${{ steps.github_repository.outputs.lc }}/${{ steps.image_ghcr.outputs.tag }}
          subject-digest: ${{ steps.image_manifest_ghcr.outputs.digest }}
          push-to-registry: true

      - name: Logout from ghcr.io
        if: ${{ always() }}
        run: docker logout ghcr.io || true

      - name: Verify image manifest
        run: |
          cosign verify \
              --key "$SIGSTORE_PUBLIC_KEY" \
              ghcr.io/${GITHUB_REPOSITORY,,}/${IMAGE_TAG}@${{ steps.image_manifest_ghcr.outputs.digest }} \
              | jq

      - name: Verify SBOM attestation
        env:
          GH_TOKEN: ${{ github.token }}
          GH_FORCE_TTY: true
        run: |
          gh attestation verify \
              --repo "$GITHUB_REPOSITORY" \
              --format json \
              --predicate-type 'https://spdx.dev/Document/v2.3' \
              oci://ghcr.io/${GITHUB_REPOSITORY,,}/${IMAGE_TAG}@${{ steps.image_manifest_ghcr.outputs.digest }}

      - name: Write release notes with transparency logs
        run: |
          cat > release_notes.md <<EOF
          Container images are available at:
            - \`ghcr.io/${GITHUB_REPOSITORY,,}/${IMAGE_TAG}@${{ steps.image_manifest_ghcr.outputs.digest }}\`
            - \`ghcr.io/${GITHUB_REPOSITORY,,}/${IMAGE_TAG}:${{ inputs.git_tag }}\`
            - \`ghcr.io/${GITHUB_REPOSITORY,,}/${IMAGE_TAG}:latest\`

          The transparency log entries is browsable at:
          - **Artifact attestation:** ${{ steps.attest_provenance.outputs.attestation-url }}
          - **SBOM attestation:** ${{ steps.attest_sbom.outputs.attestation-url }}
          EOF

      - name: Release
        env:
          GH_TOKEN: ${{ secrets.gh_token }}
        run: |
          gh release create \
              container_key_aa/${{ inputs.git_tag }} \
              --generate-notes \
              --notes-file release_notes.md \
              --title "Release of container_key_aa/${{ inputs.git_tag }}"
